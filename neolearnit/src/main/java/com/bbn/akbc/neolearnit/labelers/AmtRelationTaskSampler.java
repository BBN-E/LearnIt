package com.bbn.akbc.neolearnit.labelers;

import com.bbn.akbc.common.Pair;
import com.bbn.akbc.neolearnit.common.Annotation;
import com.bbn.akbc.neolearnit.common.InstanceIdentifier;
import com.bbn.akbc.neolearnit.common.LearnItConfig;
import com.bbn.akbc.neolearnit.mappings.filters.InstanceIdentifierFilter;
import com.bbn.akbc.neolearnit.mappings.filters.SingleDirectionFilter;
import com.bbn.akbc.neolearnit.mappings.groups.Mappings;
import com.bbn.akbc.neolearnit.observations.LearnItObservation;
import com.bbn.akbc.neolearnit.observations.label.LabelPattern;
import com.bbn.akbc.neolearnit.observations.pattern.BetweenSlotsPattern;
import com.bbn.akbc.neolearnit.observations.pattern.LearnitPattern;
import com.bbn.akbc.neolearnit.observations.pattern.PropPattern;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class AmtRelationTaskSampler implements MappingsLabeler {
    // This labeler is used for generating unlabeled causal relation for AMT turkers to work on.

    final static String NEGATIVE_TYPE = "NO_RELATION";
    static private int BETWEEN_SLOTS_PATTERN_MIN_LEXICAL_ITEMS = 1;
    static private int PROP_PATTERN_MAX_DEPTH = 3;
    static private int MIN_FREQ_OF_INSTANTANCE_IDENTIFIER = 2;
    static private int MAX_SENTENCES_PER_PATTERN_TO_ADD = 10;

    public static boolean isValidPattern(LearnitPattern learnitPattern) {
        /*
        if(!(learnitPattern instanceof PropPattern) && !(learnitPattern instanceof BetweenSlotsPattern))
            return false;
    */

        if (!(learnitPattern instanceof PropPattern))
            return false;

        if ((learnitPattern instanceof PropPattern) && !(((PropPattern) learnitPattern).hasExactlyTwoUniqueSlots()))
            return false;

        if (learnitPattern.getLexicalItemsWithContent().isEmpty()) {
//            System.out.println("Killed: "+learnitPattern.toIDString());
            return false;
        }
        if (learnitPattern instanceof LabelPattern)
            return false;

        if (learnitPattern instanceof BetweenSlotsPattern) {
            BetweenSlotsPattern p = (BetweenSlotsPattern) learnitPattern;
            return p.getLexicalItems().size() >= BETWEEN_SLOTS_PATTERN_MIN_LEXICAL_ITEMS;
        } else if (learnitPattern instanceof PropPattern) {
            PropPattern p = (PropPattern) learnitPattern;

            return p.depth() <= PROP_PATTERN_MAX_DEPTH;
        }

        return true;
    }

    public static void main(String[] args) throws Exception {
        String paramPath = args[0];
        LearnItConfig.loadParams(new File(paramPath));
        String autogeneratedMappingsPath = args[1];
        String outputLabeledMappingsPath = args[2];
        AmtRelationTaskSampler AmtRelationTaskSampler = new AmtRelationTaskSampler();
        Mappings outputMappings = AmtRelationTaskSampler.LabelMappings(Mappings.deserialize(new File(autogeneratedMappingsPath), true), new Annotation.InMemoryAnnotationStorage()).convertToMappings();
        outputMappings.serialize(new File(outputLabeledMappingsPath), true);
    }

    @Override
    public Annotation.InMemoryAnnotationStorage LabelMappings(Mappings original, Annotation.InMemoryAnnotationStorage labeledMappings) throws Exception {
        original = new InstanceIdentifierFilter().makeFiltered(original);
        original = new SingleDirectionFilter().makeFiltered(original);
        ArrayList<Pair<LearnItObservation, Set<InstanceIdentifier>>> countingMap = new ArrayList<>();

        for (LearnitPattern learnitPattern : new HashSet<>(original.getAllPatterns())) {
            if (isValidPattern(learnitPattern))
                countingMap.add(new Pair<>(learnitPattern, new HashSet<>(original.getInstancesForPattern(learnitPattern))));
        }
//        for(Seed seed: new HashSet<>(mappings.getAllSeeds())){
//            countingMap.add(new Pair<>(seed,new HashSet<>(mappings.getInstancesForSeed(seed))));
//        }

        countingMap.sort((o1, o2) -> o2.getSecond().size() - o1.getSecond().size());
        for (Pair<LearnItObservation, Set<InstanceIdentifier>> countItem : countingMap) {
            List<InstanceIdentifier> filteredInstanceIdentifier = new ArrayList<>(countItem.getSecond());
            System.out.println("LearnitObversation: " + countItem.getFirst().toIDString() + "\tSize:" + filteredInstanceIdentifier.size());
            if (countItem.getSecond().size() <= MIN_FREQ_OF_INSTANTANCE_IDENTIFIER) break;
            for (int i = 0; i < Math.min(filteredInstanceIdentifier.size(), MAX_SENTENCES_PER_PATTERN_TO_ADD); ++i) {
                labeledMappings.addAnnotation(filteredInstanceIdentifier.get(i), new LabelPattern(NEGATIVE_TYPE, Annotation.FrozenState.NO_FROZEN));
            }
        }
        return labeledMappings;
    }
}
