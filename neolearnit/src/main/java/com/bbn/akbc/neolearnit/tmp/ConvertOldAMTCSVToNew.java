package com.bbn.akbc.neolearnit.tmp;

import com.bbn.akbc.neolearnit.common.Annotation;
import com.bbn.akbc.neolearnit.common.InstanceIdentifier;
import com.bbn.akbc.neolearnit.common.LearnItConfig;
import com.bbn.akbc.neolearnit.common.MinimumInstanceIdentifier;
import com.bbn.akbc.neolearnit.common.util.SourceListsReader;
import com.bbn.akbc.neolearnit.mappings.groups.Mappings;
import com.bbn.akbc.neolearnit.observations.label.LabelPattern;
import com.bbn.akbc.neolearnit.serializers.ExternalAnnotationBuilder;
import com.bbn.akbc.neolearnit.util.GeneralUtils;
import com.bbn.bue.common.symbols.Symbol;
import com.bbn.serif.theories.EventMention;
import com.bbn.serif.theories.SentenceTheory;
import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.google.common.base.Optional;

import java.io.File;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;


public class ConvertOldAMTCSVToNew {
    public static void main(String[] args) throws Exception {
        // Old Mappings Path
        // The way of generating old mappings
        // 1. Change 364-add-event-mention-from-json EventMention span to the legacy look
        // 2. InstanceExtractor
        // 3. Change this code to make sure you construct InstanceIdentifier looks like what will happen in current corpus

        String paramPath = args[0];
        LearnItConfig.loadParams(new File(paramPath));
        String autogeneratedMappingsPath = args[1];
        String csvPath = args[2];
        String outputLabeledMappingsPath = args[3];
        Mappings autogeneratedMappings = Mappings.deserialize(new File(autogeneratedMappingsPath), true);


        int canNotAlignCounter = 0;

        Map<MinimumInstanceIdentifier, Set<InstanceIdentifier>> minimumInstanceIdentifierSetMap = new HashMap<>();
        for (InstanceIdentifier instanceIdentifier : autogeneratedMappings.getPatternInstances()) {
            MinimumInstanceIdentifier basicInstanceIdentifier = new MinimumInstanceIdentifier(instanceIdentifier.getDocid(), instanceIdentifier.getSentid(), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End(), instanceIdentifier.getSlot1Start(), instanceIdentifier.getSlot1End());
            Set<InstanceIdentifier> buf = minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier, new HashSet<>());
            buf.add(instanceIdentifier);
            minimumInstanceIdentifierSetMap.put(basicInstanceIdentifier, buf);

            basicInstanceIdentifier = new MinimumInstanceIdentifier(instanceIdentifier.getDocid(), instanceIdentifier.getSentid(), instanceIdentifier.getSlot1Start(), instanceIdentifier.getSlot1End(), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End());
            buf = minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier, new HashSet<>());
            buf.add(instanceIdentifier);
            minimumInstanceIdentifierSetMap.put(basicInstanceIdentifier, buf);
        }
        for (InstanceIdentifier instanceIdentifier : autogeneratedMappings.getSeedInstances()) {
            MinimumInstanceIdentifier basicInstanceIdentifier = new MinimumInstanceIdentifier(instanceIdentifier.getDocid(), instanceIdentifier.getSentid(), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End(), instanceIdentifier.getSlot1Start(), instanceIdentifier.getSlot1End());
            Set<InstanceIdentifier> buf = minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier, new HashSet<>());
            buf.add(instanceIdentifier);
            minimumInstanceIdentifierSetMap.put(basicInstanceIdentifier, buf);

            basicInstanceIdentifier = new MinimumInstanceIdentifier(instanceIdentifier.getDocid(), instanceIdentifier.getSentid(), instanceIdentifier.getSlot1Start(), instanceIdentifier.getSlot1End(), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End());
            buf = minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier, new HashSet<>());
            buf.add(instanceIdentifier);
            minimumInstanceIdentifierSetMap.put(basicInstanceIdentifier, buf);
        }

        CsvMapper csvMapper = new CsvMapper();
        CsvSchema csvSchema = CsvSchema.emptySchema().withHeader();
        MappingIterator<Map<String, String>> iterator = csvMapper.reader(Map.class).with(csvSchema).readValues(new File(csvPath));
        Annotation.InMemoryAnnotationStorage inMemoryAnnotationStorage = new Annotation.InMemoryAnnotationStorage();
        while (iterator.hasNext()) {
            Map<String, String> en = iterator.next();
            MinimumInstanceIdentifier basicInstanceIdentifier1 = new MinimumInstanceIdentifier(en.get("docId"), Integer.parseInt(en.get("sentId")), Integer.parseInt(en.get("slot0Start")), Integer.parseInt(en.get("slot0End")), Integer.parseInt(en.get("slot1Start")), Integer.parseInt(en.get("slot1End")));
            MinimumInstanceIdentifier basicInstanceIdentifier2 = new MinimumInstanceIdentifier(en.get("docId"), Integer.parseInt(en.get("sentId")), Integer.parseInt(en.get("slot1Start")), Integer.parseInt(en.get("slot1End")), Integer.parseInt(en.get("slot0Start")), Integer.parseInt(en.get("slot0End")));
            Set<InstanceIdentifier> instanceIdentifierSet = new HashSet<>(minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier1, new HashSet<>()));
            instanceIdentifierSet.addAll(minimumInstanceIdentifierSetMap.getOrDefault(basicInstanceIdentifier2, new HashSet<>()));

            if (instanceIdentifierSet.size() < 1) {
                canNotAlignCounter++;
            } else {
                for (InstanceIdentifier instanceIdentifier : instanceIdentifierSet) {
                    Annotation.FrozenState frozenState = Annotation.FrozenState.FROZEN_BAD;
                    if (Integer.parseInt(en.get("turker_answer")) == 5)
                        frozenState = Annotation.FrozenState.FROZEN_GOOD;
                    inMemoryAnnotationStorage.addAnnotation(instanceIdentifier, new LabelPattern("IS_CAUSAL_RELATED", frozenState));
                }
            }
        }

        Map<InstanceIdentifier, SentenceTheory> ret = new ConcurrentHashMap<>();
        Map<Symbol, Set<InstanceIdentifier>> docPathToInstanceIdetifiers = new HashMap<>();
        for (InstanceIdentifier instanceIdentifier : inMemoryAnnotationStorage.getAllInstanceIdentifier()) {
            Symbol docPath = Symbol.from(new File(SourceListsReader.getFullPath(instanceIdentifier.getDocid())).getAbsolutePath());
            Set<InstanceIdentifier> buf = docPathToInstanceIdetifiers.getOrDefault(docPath, new HashSet<>());
            buf.add(instanceIdentifier);
            docPathToInstanceIdetifiers.put(docPath, buf);
        }
        List<Callable<Boolean>> tasks = new ArrayList<>();
        for (Symbol docPath : docPathToInstanceIdetifiers.keySet()) {
            tasks.add(new ExternalAnnotationBuilder.SentenceTheorySingleDocumentWorker(docPath, docPathToInstanceIdetifiers.get(docPath), ret));
        }
        GeneralUtils.GeneralDocBasedWorkerScheduler(tasks);
        Annotation.InMemoryAnnotationStorage inMemoryAnnotationStorage1 = new Annotation.InMemoryAnnotationStorage();
        int outputCnt = 0;
        for (InstanceIdentifier instanceIdentifier : inMemoryAnnotationStorage.getAllInstanceIdentifier()) {
            final SentenceTheory sentenceTheory = ret.get(instanceIdentifier);
            EventMention left = (EventMention) InstanceIdentifier.getSpanning(sentenceTheory, instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End(), instanceIdentifier.getSlotEntityType(0)).get();
            EventMention right = (EventMention) InstanceIdentifier.getSpanning(sentenceTheory, instanceIdentifier.getSlot1Start(), instanceIdentifier.getSlot1End(), instanceIdentifier.getSlotEntityType(1)).get();
            String docId = instanceIdentifier.getDocid();
            int sentId = instanceIdentifier.getSentid();
//            int slot0Start = left.anchorNode().span().startTokenIndexInclusive();
            int slot0Start = left.anchorNode().head().span().startTokenIndexInclusive();
//            int slot0End = left.anchorNode().span().endTokenIndexInclusive();
            int slot0End = left.anchorNode().head().span().endTokenIndexInclusive();
//            int slot1Start = right.anchorNode().span().startTokenIndexInclusive();
            int slot1Start = right.anchorNode().head().span().startTokenIndexInclusive();
//            int slot1End = right.anchorNode().span().endTokenIndexInclusive();
            int slot1End = right.anchorNode().head().span().endTokenIndexInclusive();
            InstanceIdentifier instanceIdentifier1 = new InstanceIdentifier(
                    docId,
                    sentId,
                    slot0Start,
                    slot0End,
                    InstanceIdentifier.SpanningType.EventMention,
                    com.google.common.base.Optional.absent(),
                    "Generic",
                    false,
                    slot1Start, slot1End, InstanceIdentifier.SpanningType.EventMention,
                    Optional.absent(),
                    "Generic",
                    false
            );
            outputCnt++;
//            System.out.println(docId+"\t"+sentId+"\t"+slot0Start+"\t"+slot0End+"\t"+slot1Start+"\t"+slot1End);
            for (LabelPattern labelPattern : inMemoryAnnotationStorage.lookupInstanceIdentifierAnnotation(instanceIdentifier)) {
                inMemoryAnnotationStorage1.addAnnotation(instanceIdentifier1, labelPattern);
            }
//            instanceIdentifier1 = new InstanceIdentifier(
//                    docId,
//                    sentId,
//                    slot1Start,
//                    slot1End,
//                    InstanceIdentifier.SpanningType.EventMention,
//                    com.google.common.base.Optional.absent(),
//                    "Generic",
//                    false,
//                    slot0Start, slot0End, InstanceIdentifier.SpanningType.EventMention,
//                    Optional.absent(),
//                    "Generic",
//                    false
//            );
//            outputCnt++;
////            System.out.println(docId+"\t"+sentId+"\t"+slot0Start+"\t"+slot0End+"\t"+slot1Start+"\t"+slot1End);
//            for (LabelPattern labelPattern : inMemoryAnnotationStorage.lookupInstanceIdentifierAnnotation(instanceIdentifier)) {
//                inMemoryAnnotationStorage1.addAnnotation(instanceIdentifier1, labelPattern);
//            }

        }
        inMemoryAnnotationStorage1.convertToMappings().serialize(new File(outputLabeledMappingsPath), true);
        System.out.println("There are " + canNotAlignCounter + " instanceId cannot be aligned.");
        System.out.println("We output " + outputCnt + " new instanceId.");

    }
}
