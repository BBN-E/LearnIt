package com.bbn.akbc.neolearnit.labelers;

import com.bbn.akbc.neolearnit.common.Annotation;
import com.bbn.akbc.neolearnit.common.InstanceIdentifier;
import com.bbn.akbc.neolearnit.common.LearnItConfig;
import com.bbn.akbc.neolearnit.common.targets.Target;
import com.bbn.akbc.neolearnit.common.targets.TargetFactory;
import com.bbn.akbc.neolearnit.mappings.filters.TargetFilter;
import com.bbn.akbc.neolearnit.mappings.groups.Mappings;
import com.bbn.akbc.neolearnit.observations.label.LabelPattern;
import com.bbn.akbc.neolearnit.observations.pattern.LearnitPattern;
import com.bbn.akbc.neolearnit.observations.seed.Seed;
import com.bbn.akbc.neolearnit.scoring.TargetAndScoreTables;
import com.bbn.akbc.neolearnit.scoring.scores.PatternScore;
import com.bbn.akbc.neolearnit.scoring.scores.SeedScore;
import com.bbn.akbc.neolearnit.scoring.tables.AbstractScoreTable;
import com.bbn.akbc.neolearnit.util.GeneralUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class TargetAndScoreTableGoodSeedAndPatternLabeler implements MappingLabeler {

    final boolean useGoodSeeds;
    final List<TargetAndScoreTables> extractors;

    public TargetAndScoreTableGoodSeedAndPatternLabeler(String strListExtractors, boolean useGoodSeeds) throws Exception {
        this.extractors = new ArrayList<>();
        this.useGoodSeeds = useGoodSeeds;
        Map<String, TargetAndScoreTables> extractorsMap = GeneralUtils.loadExtractorsFromFileList(strListExtractors);
        extractors.addAll(extractorsMap.values());
    }

    public TargetAndScoreTableGoodSeedAndPatternLabeler(boolean useGoodSeeds) throws Exception {
        this.extractors = new ArrayList<>();
        this.useGoodSeeds = useGoodSeeds;
        String targetPathDir = String.format("%s/inputs/extractors/", LearnItConfig.get("learnit_root"));
        File dir = new File(targetPathDir);
        if (dir.exists()) {
            for (File subDir : dir.listFiles()) {
                if (subDir.isDirectory()) {
                    String targetName = subDir.getName(); // target name is the directory name

                    String latestFileTimestamp = GeneralUtils.getLatestExtractor(targetName, subDir).orNull();
                    TargetAndScoreTables ex = new TargetAndScoreTables(TargetFactory.fromString(targetName));
                    if (latestFileTimestamp != null) {
                        String fileName = String.format("%s/%s_%s.json", subDir.getAbsolutePath(),
                                targetName, latestFileTimestamp);
                        System.out.println("Loading extractor " + targetName + " from: " + fileName);
                        ex = TargetAndScoreTables.deserialize(new File(fileName));
                    }
                    extractors.add(ex);
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        String paramPath = args[0];
        LearnItConfig.loadParams(new File(paramPath));
        String autogeneratedMappingsPath = args[1];
        String outputLabeledMappingsPath = args[2];
        TargetAndScoreTableGoodSeedAndPatternLabeler targetAndScoreTableGoodSeedAndPatternLabeler = new TargetAndScoreTableGoodSeedAndPatternLabeler(false);

        Mappings original = Mappings.deserialize(new File(autogeneratedMappingsPath), true);
        Mappings labeled = targetAndScoreTableGoodSeedAndPatternLabeler.LabelMappings(original);
        labeled.serialize(new File(outputLabeledMappingsPath), true);
    }

    @Override
    public Mappings LabelMappings(Mappings original) {
        Annotation.InMemoryAnnotationStorage inMemoryAnnotationStorage = new Annotation.InMemoryAnnotationStorage();
        for (TargetAndScoreTables targetAndScoreTables : this.extractors) {
            String targetName = targetAndScoreTables.getTarget().getName();
            Target extractorTarget = targetAndScoreTables.getTarget();
            TargetFilter targetFilter = new TargetFilter(extractorTarget);
            Mappings filtered = targetFilter.makeFiltered(original);
            for (AbstractScoreTable.ObjectWithScore<LearnitPattern, PatternScore> pattern : targetAndScoreTables.getPatternScores().getObjectsWithScores()) {
                if (pattern.getScore().isFrozen() && pattern.getScore().isGood()) {
                    LearnitPattern learnitPattern = pattern.getObject();
                    for (InstanceIdentifier instanceIdentifier : filtered.getInstancesForPattern(learnitPattern)) {
                        inMemoryAnnotationStorage.addAnnotation(instanceIdentifier, new LabelPattern(targetName, Annotation.FrozenState.FROZEN_GOOD));
                    }
                }
            }
            if (this.useGoodSeeds) {
                for (AbstractScoreTable.ObjectWithScore<Seed, SeedScore> seed : targetAndScoreTables.getSeedScores().getObjectsWithScores()) {
                    if (seed.getScore().isFrozen() && seed.getScore().isGood()) {
                        Seed originalSeed = seed.getObject();
                        for (InstanceIdentifier instanceIdentifier : filtered.getInstancesForSeed(originalSeed)) {
                            inMemoryAnnotationStorage.addAnnotation(instanceIdentifier, new LabelPattern(targetName, Annotation.FrozenState.FROZEN_GOOD));
                        }
                    }
                }
            }
        }
        return inMemoryAnnotationStorage.convertToMappings();
    }
}
