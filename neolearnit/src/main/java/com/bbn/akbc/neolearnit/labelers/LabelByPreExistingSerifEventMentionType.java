package com.bbn.akbc.neolearnit.labelers;

import com.bbn.akbc.neolearnit.common.Annotation;
import com.bbn.akbc.neolearnit.common.InstanceIdentifier;
import com.bbn.akbc.neolearnit.common.LearnItConfig;
import com.bbn.akbc.neolearnit.common.bilingual.BilingualDocTheory;
import com.bbn.akbc.neolearnit.common.matchinfo.MatchInfo;
import com.bbn.akbc.neolearnit.common.util.SourceListsReader;
import com.bbn.akbc.neolearnit.mappings.groups.Mappings;
import com.bbn.akbc.neolearnit.observations.label.LabelPattern;
import com.bbn.akbc.neolearnit.serializers.ExternalAnnotationBuilder;
import com.bbn.akbc.neolearnit.util.GeneralUtils;
import com.bbn.bue.common.symbols.Symbol;
import com.bbn.serif.theories.EventMention;
import com.bbn.serif.theories.SentenceTheory;
import com.bbn.serif.theories.Spanning;
import com.google.common.base.Optional;

import java.io.File;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;

public class LabelByPreExistingSerifEventMentionType implements MappingsLabeler {

    public static void main(String[] args) throws Exception {
        LearnItConfig.loadParams(new File(args[0]));

        String autogeneratedMappingsListPath = args[1];
        String outputLabeledMappingsPath = args[2];

        List<String> mappingsPathList = GeneralUtils.readLinesIntoList(autogeneratedMappingsListPath);

        Annotation.InMemoryAnnotationStorage labeledMappings = new Annotation.InMemoryAnnotationStorage();
        LabelByPreExistingSerifEventMentionType labelByPreExistingSerifEventMentionType = new LabelByPreExistingSerifEventMentionType();

        for (String autogeneratedMappingsPath : mappingsPathList) {
            Mappings inputMappings = Mappings.deserialize(new File(autogeneratedMappingsPath), true);
            labelByPreExistingSerifEventMentionType.LabelMappings(inputMappings, labeledMappings);
        }
        labeledMappings.convertToMappings().serialize(new File(outputLabeledMappingsPath), true);
    }

    @Override
    public Annotation.InMemoryAnnotationStorage LabelMappings(Mappings original, Annotation.InMemoryAnnotationStorage labeledMappings) throws Exception {
        Set<InstanceIdentifier> instanceIdentifierSet = new HashSet<>();
        instanceIdentifierSet.addAll(original.getPatternInstances());
        instanceIdentifierSet.addAll(original.getSeedInstances());
        Set<BilingualDocTheory> binlingualDocSet = GeneralUtils.resolvedBiDocTheoryFromInstanceIdentifier(instanceIdentifierSet);
        Map<String, BilingualDocTheory> docIdToBiDoc = new HashMap<>();
        for (BilingualDocTheory bilingualDocTheory : binlingualDocSet) {
            String docId = bilingualDocTheory.getSourceDoc().docid().asString();
            docIdToBiDoc.put(docId, bilingualDocTheory);
        }
        for (InstanceIdentifier instanceIdentifier : instanceIdentifierSet) {
            BilingualDocTheory biDoc = docIdToBiDoc.get(instanceIdentifier.getDocid());
            List<Spanning> slot0SpanningSrcList = InstanceIdentifier.getSpannings(biDoc.getSourceDoc().sentenceTheory(instanceIdentifier.getSentid()), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End(), InstanceIdentifier.SpanningType.EventMention);
            for (Spanning slot0SpanningSrc : slot0SpanningSrcList) {
                EventMention em = (EventMention) slot0SpanningSrc;
                if (!em.type().asString().equals("Event")) {
                    labeledMappings.addAnnotation(instanceIdentifier, new LabelPattern(em.type().asString(), Annotation.FrozenState.FROZEN_GOOD));
                }
            }
            List<Spanning> slot0SpanningDstList = InstanceIdentifier.getSpannings(biDoc.getTargetDoc().sentenceTheory(instanceIdentifier.getSentid()), instanceIdentifier.getSlot0Start(), instanceIdentifier.getSlot0End(), InstanceIdentifier.SpanningType.EventMention);
            for (Spanning slot0SpanningDst : slot0SpanningDstList) {
                EventMention em = (EventMention) slot0SpanningDst;
                if (!em.type().asString().equals("Event")) {
                    labeledMappings.addAnnotation(instanceIdentifier, new LabelPattern(em.type().asString(), Annotation.FrozenState.FROZEN_GOOD));
                }
            }
        }
        return labeledMappings;
    }
}
