package com.bbn.akbc.neolearnit.tmp;

import com.bbn.akbc.neolearnit.common.BBNInternalOntology;
import com.bbn.akbc.neolearnit.common.InstanceIdentifier;
import com.bbn.akbc.neolearnit.common.LearnItConfig;
import com.bbn.akbc.neolearnit.common.targets.Target;
import com.bbn.akbc.neolearnit.common.targets.TargetFactory;
import com.bbn.akbc.neolearnit.common.targets.TargetSlot;
import com.bbn.akbc.neolearnit.common.targets.constraints.impl.SpanningTypeConstraint;
import com.bbn.akbc.neolearnit.mappings.filters.TargetFilter;
import com.bbn.akbc.neolearnit.mappings.groups.Mappings;
import com.bbn.akbc.neolearnit.observations.pattern.LearnitPattern;
import com.bbn.akbc.neolearnit.observations.pattern.UnaryPattern.HeadWordPOSTagPattern;
import com.bbn.akbc.neolearnit.observations.seed.Seed;
import com.bbn.akbc.neolearnit.scoring.TargetAndScoreTables;
import com.bbn.akbc.neolearnit.scoring.scores.PatternScore;
import com.bbn.akbc.neolearnit.scoring.scores.SeedScore;
import com.bbn.bue.common.symbols.SymbolUtils;
import com.google.common.collect.ImmutableSet;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;

public class ExamplerToTargetAndScoreTable {
    public static boolean hasKeyword(Iterable<String> words, Collection<String> keywords) {
        for (String w : words) {
            w = w.toLowerCase();
            for (String key : keywords) {
                if (key.endsWith("*")) {
                    if (w.startsWith(key.substring(0, key.length() - 1))) return true;
                } else {
                    if (w.equals(key)) return true;
                }
            }
        }
        return false;
    }

    static String getNowDateString() {
        Date date = new Date();
        String timeString = (new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss").format(date))
                .replace("-", "");
        return timeString;
    }

    public static void main(String[] args) throws Exception {
        String paramPath = args[0];
        LearnItConfig.loadParams(new File(paramPath));
        String autogeneratedMappingsPath = args[1];
        String yamlOntologyPath = args[2];
        String dataExamplePath = args[3];
        BBNInternalOntology.BBNInternalOntologyNode ontologyRoot = BBNInternalOntology.BBNInternalOntologyNode.fromInternalOntologyFile(new File(yamlOntologyPath));

        Map<String, BBNInternalOntology.BBNInternalOntologyNode> nodeIdToNode = ontologyRoot.getPropToNodeMap(new BBNInternalOntology.BBNInternalOntologyNode.PropStringGetter("_id"));
        BBNInternalOntology.bindTriggerExampleToOntologyTree(ontologyRoot, dataExamplePath);
        Target target = TargetFactory.makeUnaryEventTarget();

        Mappings autogeneratedMappings = Mappings.deserialize(new File(autogeneratedMappingsPath), true);
        TargetFilter targetFilter = new TargetFilter(target);
        autogeneratedMappings = targetFilter.makeFiltered(autogeneratedMappings);
        String nowDateString = getNowDateString();
        Set<String> whitelistedEventTypes = new HashSet<>();
        whitelistedEventTypes.add("import_001");
        whitelistedEventTypes.add("export_001");
        whitelistedEventTypes.add("human_displacement_001");
        whitelistedEventTypes.add("precipitation_002");
        whitelistedEventTypes.add("death_001");
        whitelistedEventTypes.add("inflation_001");
        whitelistedEventTypes.add("economic_activity_001");
        whitelistedEventTypes.add("currency_devaluation_001");
        whitelistedEventTypes.add("market_001");
        whitelistedEventTypes.add("shortage_001");
        whitelistedEventTypes.add("trend_001");
        whitelistedEventTypes.add("famine_001");
        whitelistedEventTypes.add("agriculture_production_001");

        Set<String> stopWordSet = new HashSet<>();
//        stopWordSet.add();


        for (String nodeId : nodeIdToNode.keySet()) {
            if (!whitelistedEventTypes.contains(nodeId)) continue;
            BBNInternalOntology.BBNInternalOntologyNode node = nodeIdToNode.get(nodeId);
            String originalName = node.originalKey;
            Set<LearnitPattern> pendingAddPatterns = new HashSet<>();
            Set<Seed> pendingAddSeed = new HashSet<>();


            for (String kwd : new HashSet<>(node._examples)) {
                if (stopWordSet.contains(kwd.toLowerCase())) continue;
                for (LearnitPattern pattern : autogeneratedMappings.getInstance2Pattern().getAllPatterns().elementSet()) {
                    if (hasKeyword(SymbolUtils.toStringSet(pattern.getLexicalItems()), ImmutableSet.of(kwd))) {
                        if ((pattern instanceof HeadWordPOSTagPattern)) {
                            pendingAddPatterns.add(pattern);
                        }
                    }

                }

//                for (Seed seed : autogeneratedMappings.getInstance2Seed().getAllSeeds().elementSet()) {
//                    if (seed.getSlot(0).toString().contains(kwd)) {
//                        pendingAddSeed.add(seed);
//                    }
//                }
            }
            if (pendingAddPatterns.size() > 0 || pendingAddSeed.size() > 0) {
                String targetPathRel = String.format("inputs/targets/json/%s.json", originalName);
                String targetPathFull = String.format("%s/%s", LearnItConfig.get("learnit_root"), targetPathRel);

                Target newTarget;
                Target.Builder newTargetBuilder;
                newTargetBuilder = new Target.Builder(originalName)
                        .setDescription("")
                        .withTargetSlot(new TargetSlot.Builder(0, "all")
                                .build()).withTargetSlot(new TargetSlot.Builder(1, "all")
                                .build());
                newTargetBuilder.withAddedConstraint(new SpanningTypeConstraint(0, Arrays.asList(InstanceIdentifier.SpanningType.EventMention)));
                newTargetBuilder.withAddedConstraint(new SpanningTypeConstraint(1, Arrays.asList(InstanceIdentifier.SpanningType.Empty)));
                newTarget = newTargetBuilder.build();
                try {
                    newTarget.serialize(targetPathFull);

                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException(e.getMessage());
                }

                TargetAndScoreTables targetAndScoreTables = new TargetAndScoreTables(targetPathFull);

                for (LearnitPattern learnitPattern : pendingAddPatterns) {
                    targetAndScoreTables.getPatternScores().addDefault(learnitPattern);
                    PatternScore patternScore = targetAndScoreTables.getPatternScores().getScore(learnitPattern);
                    patternScore.setPrecision(0.95);
                    patternScore.setConfidence(1.0);
                    patternScore.setConfidenceNumerator(patternScore.getConfidenceDenominator() * patternScore.getConfidence());
                    patternScore.freezeScore(targetAndScoreTables.getIteration());
                }

                for (Seed seed : pendingAddSeed) {
                    targetAndScoreTables.getSeedScores().addDefault(seed);
                    SeedScore seedScore = targetAndScoreTables.getSeedScores().getScore(seed);
                    seedScore.setScore(1.0);
                    seedScore.setConfidence(1.0);
                    seedScore.freezeScore(targetAndScoreTables.getIteration());
                }
                String strTargetPathDir = String.format("%s/%s/", String.format("%s/inputs/extractors/", LearnItConfig.get("learnit_root")), targetAndScoreTables.getTarget().getName());
                File dir = new File(strTargetPathDir);
                if (!dir.exists()) {
                    dir.mkdir();
                }
                String strPathJson = strTargetPathDir + targetAndScoreTables.getTarget().getName() + "_" +
                        nowDateString + ".json";
                System.out.println("\t serializing extractor for " + targetAndScoreTables + "...");
                targetAndScoreTables.serialize(new File(strPathJson));
                System.out.println("\t\t...done.");

            }

        }
    }
}
