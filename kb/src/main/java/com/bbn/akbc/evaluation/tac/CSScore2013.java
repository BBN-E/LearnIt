package com.bbn.akbc.evaluation.tac;

// Scorer for TAC KBP 2012 Cold Start task
// Author:  Hoa Dang (hoa.dang@nist.gov)

// V1.1
// Date: October 16, 2012
//   * Allow optional specification of maximum number of hops to evaluate for each entry point query.
//   * Added final P/R/F1 scores over all responses up to the maximum number of hop levels evaluated.
//   * Trim whitespace (if any) around response IDs.

// V1.0
// Date: October 11, 2012
//
// Each line in the response ID file has the following tab-separated columns:
//
// Column 1: response source
// Column 2: response ID contributed to the assessment file
//
// The response source and response IDs are generated by Jim Mayfield using the submitted KB and a query file.
//
// The slot key file is LDC's assessment file. Each line contains 13
// tab-separated fields. The field definitions are as follows:

//  Column 1: response ID

//  Column 2: query and hop ID (e.g. CS_ENG_001_00)

//  Column 3: parent ID (ID for the response from the previous hop level
//            that generated the equivalence class that (together with Column 2) now acts as the query
//            entity; NIL if 0 hop, in which case the query entity is specified in a separate queries file)
//
//  Column 4: slot name
//
//  Column 5: docid that justifies the relation between the query
//            entity and the slot filler
//
//  Column 6: [possibly normalized] slot filler string
//
//  Column 7: start offset of unnormalized filler
//
//  Column 8: end offset of unnormalized filler
//
//  Column 9: start offset of justification
//
//  Column 10: end offset of justification
//
//  Column 11: judgment for slot filler string:
//
//  	    	     -1 - Wrong
// 		      1 - Correct
// 		      3 - Inexact
// 		      4 - Not assessed
//
//  Column 12: judgment for justification:
//
//  	    	     -1 - Wrong
// 		      1 - Correct
// 		      3 - Inexact
// 		      4 - Not assessed
//
//  Column 13: equivalence class for slot filler string if Correct (0 otherwise)
//


import java.io.*;
import java.util.*;

public class CSScore2013 {

  // Maximum number of hops to evaluate for each entry point query
  static int max_eval_hops = 1; // varies by year and evalution

  // true to print out judgement for each line of response
  static boolean trace = false;

  // true to ignore docId ... score only on value
  static boolean anydoc = false;

  // true to ignore case in answers
  static boolean nocase = false;

  // tables built from judgement file

  // mapping from hop level to assessment lines for responses at that hop level
  static Map<Integer, List<String>> hop_level = new HashMap<Integer, List<String>>();

  // mapping from response id to augmented query id
  static Map<String, String> response_to_query_id = new HashMap<String, String>();

  //  mapping from response_id --> judgement
  static Map<String, Integer> judgement = new HashMap<String, Integer>();

  //  mapping from response_id --> equivalence class
  static Map<String, String> equivalenceClass = new HashMap<String, String>();

  //  mapping from augmented query_id --> {true, false}
  static Map<String, Boolean> query_has_answer = new HashMap<String, Boolean>();

  //  mapping from augmented query_id --> set of equivalence classes
  static Map<String, Set<String>> query_eclasses = new HashMap<String, Set<String>>();

  // table built from response file

  //  mapping from augmented entity_id --> list[response_id]
  static Map<String, List<String>> response = new HashMap<String, List<String>>();

  // codes in judgement file
  static final int WRONG = -1;
  static final int CORRECT = 1;
  static final int REDUNDANT = 2;
  static final int INEXACT = 3;
  static final int UNASSESSED = 4;
  // not assessed, usually because earlier entity in the path was not Correct

  // next unique equivalence class
  static int eclass_generator = 1000000;

  static String slotFile = null;

  static Set<String> slots = new TreeSet<String>();

  /**
   * CSScorer <response file> <key file> scores response file against key file
   */

  public static void main(String[] args) throws IOException {

    if (args.length < 2 || args.length > 5) {
      System.out.println("SlotScorer must be invoked with 2 to 5 arguments:");
      System.out.println("\t<response ID file>  <key file> [flag ...]");
      System.out.println("flags:");
      System.out.println("\ttrace  -- print a line with assessment of each system response");
      //	    System.out.println ("\tanydoc -- judge response based only on answer string, ignoring doc id");
      //	    System.out.println ("\tnocase -- ignore case in matching answer string");
      System.out.println("\thops=<max_hops> -- maximum hop level to evaluate (default is 1)");
      System.out.println("\tslots=<slotfile> -- take list of entityId:slot pairs from slotfile");
      System.out.println("\t                    (otherwise list of pairs is taken from key file)");
      System.exit(1);
    }
    String responseFile = args[0];
    String keyFile = args[1];
    for (int i = 2; i < args.length; i++) {
      String flag = args[i];
      if (flag.equals("trace")) {
        trace = true;
        // } else if (flag.equals("anydoc")) {
        // 	anydoc = true;
        // } else if (flag.equals("nocase")) {
        // 	nocase = true;
      } else if (flag.startsWith("slots=")) {
        slotFile = flag.substring(6);
      } else if (flag.startsWith("hops=")) {
        try {
          max_eval_hops = Integer.parseInt(flag.substring(5));
        } catch (NumberFormatException e) {
          System.out.println("Invalid value for hops= :" + flag.substring(5));
          System.exit(1);
        }
      } else {
        System.out.println("Unknown flag: " + flag);
        System.exit(1);
      }
    }

    // ----------- read in slot judgements ------------

    BufferedReader keyReader = null;
    try {
      keyReader = new BufferedReader(new FileReader(keyFile));
    } catch (FileNotFoundException e) {
      System.out.println("Unable to open judgement file " + keyFile);
      System.exit(1);
    }
    String line;
    int max_hops = 0;
    while ((line = keyReader.readLine()) != null) {
      String[] fields = line.trim().split("\t", 13);
      if (fields.length != 13) {
        System.out.println("Warning: Invalid line in judgement file:");
        System.out.println(line);
        System.exit(1);
      }
      String query_id = fields[1];
      String query_fields[] = query_id.split("_");
      Integer hop;
      try {
        hop = Integer.parseInt(query_fields[query_fields.length - 1]);
      } catch (NumberFormatException e) {
        System.out
            .println("Warning: Invalid line in judgement file -- invalid hop level in query:");
        System.out.println(line);
        continue;
      }
      if (hop_level.get(hop) == null) {
        hop_level.put(hop, new ArrayList<String>());
      }
      hop_level.get(hop).add(line);
      if (hop > max_hops) {
        max_hops = hop;
      }
    }

    if (max_eval_hops > max_hops) {
      System.out.println("Warning: maximim hop level to evaluate (" + max_eval_hops
          + ") is too high; evaluating only up through hop level to " + max_hops);
      max_eval_hops = max_hops;
    }
    // process judgments one hop level at a time, in increasing order of hop level
    for (int hop = 0; hop <= max_hops; hop++) {
      List<String> assessmentlinesList = hop_level.get(hop);
      if (assessmentlinesList == null) {
        System.out.println("Warning: No assessements for responses at hop level " + hop);
        break;
      }

      for (String aline : assessmentlinesList) {

        String[] fields = aline.trim().split("\t", 13);
        String response_id = fields[0];
        response_id = response_id.trim();
        String query_id = fields[1];
        String parent_id = fields[2];
        String slot_name = fields[3];
        //		String doc_id = fields[4];

        // if (anydoc)
        //     doc_id = "*";
        // String answerString = fields[5];
        // answerString = answerString.trim();
        // if (nocase)
        //     answerString = answerString.toLowerCase();
        int jment = 0;
        try {
          jment = Integer.parseInt(fields[10]);
        } catch (NumberFormatException e) {
          System.out.println("Warning: Invalid line in judgement file -- invalid judgement:");
          System.out.println(aline);
          System.exit(1);
        }
        String eclass_label = fields[12];
        if (eclass_label == "0") {
//				if (eclass_label.equals("0")) {
          eclass_label = Integer.toString(eclass_generator++);
        }

        String parent_eclass = "0";
        if (!parent_id.equals("NIL")) {
          parent_eclass = equivalenceClass.get(parent_id);
        }

        if (parent_eclass == null) {
          System.out.println("Warning: Invalid line in judgement file -- invalid parent ID:");
          System.out.println(aline);
          System.exit(1);
        }

        if (!parent_id.equals("NIL") && parent_eclass.equals("0")) {
          if (jment == CORRECT) {
            System.out.println(
                "Warning: Invalid line in judgement file -- CORRECT judgment for filler when parent is not CORRECT:");
            System.out.println(aline);
            continue;
          }
        }

        // rename query to associate with eclass of parent;
        // also append slot name at this hop, to identify slot
        // type (single- or list-valued)
        query_id = query_id + ":" + slot_name + ":" + parent_eclass;

        // construct unique identifier for slot filler entity in this path
        String eclass = query_id + ":" + eclass_label;

        String key = response_id;

        // String key_string = query_id + ":" + doc_id + ":" + answerString;
        // might want to judgement.get(key_string) at some point after the official evaluation

        Integer J = judgement.get(key);
        if (J != null) {  // should never happen in official evaluation
          if (jment != J) {  // make sure judgments match
            System.out.println("Multiple conflicting judgments for response " + key);
            System.exit(1);
          }
          if (jment == CORRECT) {  // make sure eclasses of CORRECT responses match
            if (equivalenceClass.get(key) != eclass) {
              System.out.println("Multiple equivalence classes for response " + key);
              System.exit(1);
            }
          }
        } else {
          judgement.put(key, jment);
          equivalenceClass.put(key, eclass);
          if (jment == CORRECT) {
            query_has_answer.put(query_id, true);
            if (query_eclasses.get(query_id) == null) {
              query_eclasses.put(query_id, new HashSet<String>());
            }
            query_eclasses.get(query_id).add(eclass);
          }
        }

        slots.add(query_id);
        response_to_query_id.put(response_id, query_id);
      }
    }
    System.out.println("Read " + judgement.size() + " judgements.");

    // -------------- read list of slots ----------
    //   separate into single and list valued slots, at each hop level

    if (slotFile != null) {
      slots = new TreeSet<String>(readLines(slotFile));
    }
    Map<Integer, List<String>> svSlots = new HashMap<Integer, List<String>>();
    Map<Integer, List<String>> lSlots = new HashMap<Integer, List<String>>();
    for (String slot : slots) {
      String type = slotType(slot);
      Integer hop = hopLevel(slot);
      if (type == "single") {
        if (svSlots.get(hop) == null) {
          svSlots.put(hop, new ArrayList<String>());
        }
        svSlots.get(hop).add(slot);
      } else if (type == "list") {
        if (lSlots.get(hop) == null) {
          lSlots.put(hop, new ArrayList<String>());
        }
        lSlots.get(hop).add(slot);

      }
    }

    // --------- read in system responses -------------

    BufferedReader responseReader = null;
    try {
      responseReader = new BufferedReader(new FileReader(responseFile));
    } catch (FileNotFoundException e) {
      System.out.println("Unable to open response file " + responseFile);
      System.exit(1);
    }

    while ((line = responseReader.readLine()) != null) {
      String[] fields = line.trim().split("\t", 2);
      if (fields.length != 2) {
        System.out.println("Warning: Invalid line in response file:  " + fields.length + " fields");
        System.out.println(line);
        continue;
      }
      String response_id = fields[1];
      response_id = response_id.trim();
      String query_id = response_to_query_id.get(response_id);
      if (query_id == null) {
        System.out.println("Warning: No judgment for response in response file: ");
        System.out.println(line);
        continue;
      }
      if (response.get(query_id) == null) {
        response.put(query_id, new ArrayList<String>());
      }
      response.get(query_id).add(response_id);
    }

    System.out.println("Read responses for " + response.size() + " slots.");

    // ------------- score responses ------------

    if (slotFile != null) {
      System.out.println("Slot lists taken from file " + slotFile);
    } else {
      System.out.println("Slot lists taken from assessment file");
    }

    int num_svSlots = 0;
    int num_lSlots = 0;
    int total_num_answers = 0;
    int total_num_responses = 0;
    int total_num_correct = 0;
    int total_num_redundant = 0;
    int total_num_wrong = 0;
    int total_num_parentwrong = 0;
    int total_num_inexact = 0;

    for (int hop = 0; hop <= max_eval_hops; hop++) {

      //          for single-valued slots

      // counts for slots with some system response
      int num_sv_slots = 0;
      int num_l_slots = 0;
      // number of non-NIL responses
      int num_responses = 0;
      // number of correct non-NIL responses
      int num_correct = 0;
      // counts for different error types
      int num_wrong = 0;  // includes spurious and incorrect
      int num_parentwrong = 0;  // UNASSESSED (wrong) because parent slot filler is not CORRECT
      int num_inexact = 0;
      int num_redundant = 0;
      // number of correct answers in key
      //   (correct single-value answers + list-value equivalence classes)
      int num_answers = 0;
      String symbol = "?";

      for (String query : svSlots.get(hop)) {
        if (query_has_answer.get(query) != null) {
          num_answers++;
        }
        List<String> responseList = response.get(query);
        if (responseList == null) {
          if (query_has_answer.get(query) != null) {
            // missing slot fill
            symbol = "M";
          } else {
            symbol = "C";
          }
          if (trace) {
            if (symbol.equals("C")) {
              System.out.println("trace " + hop + " " + symbol + " " + query + " NIL " + "NIL");
            } else {
              for (String eclass : query_eclasses.get(query)) {
                System.out.println("trace " + hop + " " + symbol + " " + query + " NIL " + eclass);
              }
            }
          }
        } else { /* non-NIL system response */
          num_sv_slots++;
          boolean answer_found = false;

          // KB might have accidentally split the parent,
          // returning more than one value for a single-valued
          // slot.  Correct if any of the responses is Correct;
          // all other responses besides first Correct response
          // are spurious (redundant, inexact, etc.)
          for (String responseString : responseList) {
            num_responses++;
            Integer J = judgement.get(responseString);
            if (J == null) {
              System.out.println("Warning: No judgement for " + responseString);
              J = WRONG;
            }
            int j = J;
            switch (j) {
              case UNASSESSED:
                num_parentwrong++;
                symbol = "P";
                break;
              case WRONG:
                num_wrong++;
                symbol = "W";
                break;
              case CORRECT:
                if (answer_found) {
                  num_redundant++;
                  symbol = "r";   // redundant with other returned response
                } else {
                  num_correct++;
                  symbol = "C";
                  answer_found = true;
                }
                break;
              case INEXACT:
                num_inexact++;
                symbol = "X";
                break;
              default:
                System.out.println("Warning: Invalid judgement " + j);
                System.exit(1);
            }
            if (trace) {
              if (symbol.equals("C")) {
//								Set<String> setEclasses = query_eclasses.get(query);
//								assert(setEclasses.size()==1);
//								System.out.println ("trace " + hop + " " + symbol + " " + query + " " + responseString + " " + query_eclasses.get(query).toArray()[0]);
                System.out.println(
                    "trace " + hop + " " + symbol + " " + query + " " + responseString + " "
                        + equivalenceClass.get(responseString));
              } else {
                System.out.println(
                    "trace " + hop + " " + symbol + " " + query + " " + responseString + " "
                        + "NIL");
              }
            }
          }
        }
      }

      // ------------- score responses ------------
      //           for list-valued slots

      for (String query : lSlots.get(hop)) {
        int num_answers_to_query = 0;
        if (query_eclasses.get(query) != null) {
          num_answers_to_query = query_eclasses.get(query).size();
        }
        num_answers += num_answers_to_query;
        List<String> responseList = response.get(query);
        if (responseList == null) {  // "NIL" response
          if (query_has_answer.get(query) != null) {
            // missing system response
            symbol = "M";
          } else {
            symbol = "C";
          }
          if (trace) {
            if (symbol.equals("C")) {
              System.out.println("trace " + hop + " " + symbol + " " + query + " NIL " + "NIL");
            } else {
              for (String eclass : query_eclasses.get(query)) {
                System.out.println("trace " + hop + " " + symbol + " " + query + " NIL " + eclass);
              }
            }
          }
        } else { /* non-NIL system response */
          num_l_slots++;
          Set<String> distincts = new HashSet<String>();
          for (String responseString : responseList) {
            //		String fields[] = responseString.split(":",2);
            //		String doc_id = fields[0];
            //		String answer_string = "";
            //		if (fields.length == 2)
            //		    answer_string = fields[1];

            num_responses++;
            //		    String key = query + ":" + doc_id + ":" + answer_string;
            String key = responseString;
            Integer J = judgement.get(key);
            if (J == null) {
              System.out.println("Warning: No judgement for " + key);
              J = WRONG;
            }
            int j = J;
            switch (j) {
              case UNASSESSED:
                num_parentwrong++;
                symbol = "P";
                break;
              case WRONG:
                num_wrong++;
                symbol = "W";
                break;
              case CORRECT:
                String E = equivalenceClass.get(key);
                if (distincts.contains(E)) {
                  num_redundant++;
                  symbol = "r";   // redundant with other returned response
                } else {
                  num_correct++;
                  symbol = "C";
                  distincts.add(E);
                }
                break;
              case INEXACT:
                num_inexact++;
                symbol = "X";
                break;
              default:
                System.out.println("Warning: Invalid judgement " + j);
                System.exit(1);
            }
            if (trace) {
//							System.out.println ("trace " + hop + " " + symbol + " " + query + " " + responseString + " " + equivalenceClass.get(key));
              if (symbol.equals("C")) {
                System.out.println(
                    "trace " + hop + " " + symbol + " " + query + " " + responseString + " "
                        + equivalenceClass.get(responseString));
              } else {
                System.out.println(
                    "trace " + hop + " " + symbol + " " + query + " " + responseString + " "
                        + "NIL");
              }
            }
          }

          // missed equivalent answers
          if (query_eclasses.get(query) != null) {
            for (String eclass : query_eclasses.get(query)) {
              if (!distincts.contains(eclass)) {
                System.out
                    .println("trace " + hop + " " + "M" + " " + query + " " + "NIL" + " " + eclass);
              }
            }
          }
        }
      }
      num_svSlots += svSlots.get(hop).size();
      num_lSlots += lSlots.get(hop).size();
      total_num_answers += num_answers;
      total_num_responses += num_responses;
      total_num_correct += num_correct;
      total_num_redundant += num_redundant;
      total_num_wrong += num_wrong;
      total_num_parentwrong += num_parentwrong;
      total_num_inexact += num_inexact;
      System.out.println("\nHop Level: " + hop);
      System.out.println("Slot lists include " + svSlots.get(hop).size() + " single valued slots");
      System.out.println("               and " + lSlots.get(hop).size() + " list-valued slots");
      System.out.println("\tNumber of filled slots in key: " + num_answers);
      System.out.println("\tNumber of filled slots in response: " + num_responses);
      System.out.println("\tNumber correct (C), non-NIL: " + num_correct);
      System.out.println("\tNumber redundant (r): " + num_redundant);
      System.out.println("\tNumber incorrect (W): " + num_wrong);
      System.out.println("\tNumber incorrect because of incorrect parent (P): " + num_parentwrong);
      System.out.println("\tNumber inexact (X): " + num_inexact);

      float recall = ((float) num_correct) / num_answers;
      float precision = ((float) num_correct) / num_responses;
      float F = (2 * recall * precision) / (recall + precision);
      System.out.println("Scores:");
      System.out.println("\tRecall: " + num_correct + " / " + num_answers + " = " + recall);
      System.out.println("\tPrecision: " + num_correct + " / " + num_responses + " = " + precision);
      System.out.println("\tF1: " + F + "\n");
    }
    System.out.println("\nAll Hop Levels from 0 up through " + max_eval_hops + ":");
    System.out.println("Slot lists include " + num_svSlots + " single valued slots");
    System.out.println("               and " + num_lSlots + " list-valued slots");
    System.out.println("\tNumber of filled slots in key: " + total_num_answers);
    System.out.println("\tNumber of filled slots in response: " + total_num_responses);
    System.out.println("\tNumber correct (C), non-NIL: " + total_num_correct);
    System.out.println("\tNumber redundant (r): " + total_num_redundant);
    System.out.println("\tNumber incorrect (W): " + total_num_wrong);
    System.out
        .println("\tNumber incorrect because of incorrect parent (P): " + total_num_parentwrong);
    System.out.println("\tNumber inexact (X): " + total_num_inexact);

    float recall = ((float) total_num_correct) / total_num_answers;
    float precision = ((float) total_num_correct) / total_num_responses;
    float F = (2 * recall * precision) / (recall + precision);
    System.out.println("Scores:");
    System.out
        .println("\tRecall: " + total_num_correct + " / " + total_num_answers + " = " + recall);
    System.out.println(
        "\tPrecision: " + total_num_correct + " / " + total_num_responses + " = " + precision);
    System.out.println("\tF1: " + F + "\n");
  }

  /**
   * reads a series of lines from 'fileName' and returns them as a list of Strings
   */

  static List<String> readLines(String fileName) {
    BufferedReader reader = null;
    List<String> lines = new ArrayList<String>();
    try {
      reader = new BufferedReader(new FileReader(fileName));
    } catch (FileNotFoundException e) {
      System.out.println("Unable to open file " + fileName);
      System.exit(1);
    }
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        lines.add(line.trim());
      }
    } catch (IOException e) {
      System.out.println("Error readng from file " + fileName);
      System.exit(1);
    }
    System.out.println("Read " + lines.size() + " lines from " + fileName);
    return lines;
  }

  static List<String> singleValuedSlots = Arrays.asList(
      "per:date_of_birth",
      "per:age",
      "per:country_of_birth",
      "per:stateorprovince_of_birth",
      "per:city_of_birth",
      "per:date_of_death",
      "per:country_of_death",
      "per:stateorprovince_of_death",
      "per:city_of_death",
      "per:cause_of_death",
      "per:religion",
      "org:number_of_employees_members",
      "org:date_founded",
      "org:date_dissolved",
      "org:country_of_headquarters",
      "org:stateorprovince_of_headquarters",
      "org:city_of_headquarters",
      "org:website");

  static List<String> listValuedSlots = Arrays.asList(
      "per:alternate_names",
      "per:origin",
      "per:countries_of_residence",
      "per:statesorprovinces_of_residence",
      "per:cities_of_residence",
      "per:schools_attended",
      "per:title",
      "per:member_of",
      "per:employee_of",
      "per:spouse",
      "per:children",
      "per:parents",
      "per:siblings",
      "per:other_family",
      "per:charges",
      "org:alternate_names",
      "org:political_religious_affiliation",
      "org:top_members_employees",
      "org:members",
      "org:member_of",
      "org:subsidiaries",
      "org:parents",
      "org:founded_by",
      "org:shareholders",

      // Cold Start inverse slots added to regular slot-filling slots
      "org:employees",
      "gpe:employees",
      "gpe:member_of",
      "org:membership",
      "org:students",
      "gpe:births_in_city",
      "gpe:births_in_stateorprovince",
      "gpe:births_in_country",
      "gpe:residents_of_city",
      "gpe:residents_of_stateorprovince",
      "gpe:residents_of_country",
      "gpe:deaths_in_city",
      "gpe:deaths_in_stateorprovince",
      "gpe:deaths_in_country",
      "per:holds_shares_in",
      "org:holds_shares_in",
      "gpe:holds_shares_in",
      "per:organizations_founded",
      "org:organizations_founded",
      "gpe:organizations_founded",
      "per:top_member_employee_of",
      "gpe:headquarters_in_city",
      "gpe:headquarters_in_stateorprovince",
      "gpe:headquarters_in_country",

      // 2013 slots
      "per:employee_or_member_of",
      "org:employees_or_members",
      "gpe:employees_or_members");
        /*
         * given queryId:slot:parent_eclass, classify slot as "single" or "list" valued
	 */

  static String slotType(String slot) {
    String[] slotFields = slot.split(":", 4);
    if (slotFields.length != 4) {
      System.out.println("Invalid slot " + slot);
      return "error";
    }
    String slot_name = slotFields[1] + ":" + slotFields[2];
    if (singleValuedSlots.contains(slot_name)) {
      return "single";
    }
    if (listValuedSlots.contains(slot_name)) {
      return "list";
    }
    System.out.println("Invalid slot " + slot);
    return "error";
  }

	/*
         * given queryId:slot:parent_eclass, return hop level (from queryId)
	 */

  static Integer hopLevel(String slot) {
    String[] slotFields = slot.split(":", 3);
    if (slotFields.length != 3) {
      System.out.println("Invalid slot " + slot);
      return -1;
    }
    String query_id = slotFields[0];
    String query_fields[] = query_id.split("_");
    Integer hop = Integer.parseInt(query_fields[query_fields.length - 1]);
    return hop;
  }
}
